# React and Express Backend - Cursor AI Rules

## Building React + Express.js Apps for SPCS Deployment

**CRITICAL**: Always start by finding a working SPCS reference app. Use https://github.com/sfc-gh-ujagtap/sun_valley_spcs as the proven reference. Don't reinvent the wheel - compare systematically and replicate exactly. Complexity in Docker/build = architectural problems upstream.

### Core Architecture Principles

1. **Use Flat Project Structure** 
   - ✅ Use: Root-level React app with single `package.json`
   - Pattern: `src/`, `public/`, `build/`, `server.js` all at project root
   - Express serves both API routes AND static React build files

2. **Port Strategy - Always 3002**
   - Use port 3002 consistently across ALL environments
   - Local development, Docker, SPCS service spec - all port 3002

3. **TypeScript Over JavaScript**
   - Convert `.js` to `.tsx` for better development experience
   - Add `tsconfig.json` from https://github.com/sfc-gh-ujagtap/sun_valley_spcs

## Building Phase

### Express Server Configuration
Implement per-request Snowflake connection pattern (CRITICAL):
```javascript
// Fresh connection per API request - prevents timeouts
async function connectToSnowflake() {
    const connection = snowflake.createConnection(snowflakeConfig);
    await new Promise((resolve, reject) => {
        connection.connect((err, conn) => {
            if (err) reject(err);
            else resolve(conn);
        });
    });
    return connection;
}

// Always destroy connection after use
app.get('/api/endpoint', async (req, res) => {
    let connection;
    try {
        connection = await connectToSnowflake();
        const rows = await executeQuery(connection, query);
        res.json(rows);
    } catch (error) {
        res.status(500).json({ error: 'Failed to fetch data' });
    } finally {
        if (connection) {
            connection.destroy(); // CRITICAL: Always cleanup
        }
    }
});
```

### Database Setup
- Look at user prompt to see if the app needs access to the existing database 
- Implement sample data if no database is provided in the prompt
- Keep any database setup in a single script file
- Use `CREATE IF NOT EXISTS` for idempotency

###Warehouse & SPCS Service Setup
- Look for the warehouse to use in the prompt
- If no warehouse is specified, create a new one and use it for creating and accessing data
- Create deploy.sql to create a service with inline specs including the warehouse used
- Create separate files for image repo setup, service setup and managing service under spcs folder
 
### Role Access
- Every app should provision a new account level role named specifically for the app
- This role should own the SPCS service, warehouse and sample dataset
- This role should also be granted any existing databases provided in the prompt
- SPCS service should access the data with the provisioned role
- This role should be granted to the current user

### Dual Authentication Setup in Express Server for Data Access
- Container detection: `fs.existsSync("/snowflake/session/token")`
- SPCS: OAuth with `token: fs.readFileSync('/snowflake/session/token', 'ascii')`
- Local: Read from `~/.snowsql/config` with warehouse specified
- Add `accessUrl` to Snowflake config for SPCS
- Dynamic logging: "Available via SPCS endpoint" when in container, local URL when not

### Essential Endpoints
- Health check: `app.get('/api/health', (req, res) => res.json({status: 'OK'}))`
- Static files: `app.use(express.static('build'))`
- React routing: `app.get('*', (req, res) => res.sendFile(path.join(__dirname, 'build', 'index.html')))`
- ⚠️ **Never hardcode localhost** - use dynamic container detection for environment-specific behavior

### React Frontend
- Use TypeScript interfaces for all data structures
- Add loading states and error boundaries
- Include professional visualizations (Recharts, etc.)

## Testing Phase
### Local Development
1. **Build process**: Ensure `npm run build` creates clean `build/` directory
2. **Test locally**: Verify React app loads with proper styling and functionality
3. **Database connection**: Test both local and mock data scenarios
4. **API endpoints**: Verify all `/api/*` routes work correctly

### Docker Testing
1. **Build locally**: `docker build --platform linux/amd64 -t app-name:latest .`
2. **Run container**: `docker run -p 3002:3002 app-name:latest`
3. **Verify health**: Access `/api/health` endpoint on container port 3002
4. **Test full app**: Verify React app loads and functions correctly

## Deployment Phase

### Multi-stage Dockerfile
```dockerfile
# Builder stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --legacy-peer-deps 
COPY . .
RUN npm run build

# Production stage  
FROM node:18-alpine AS production
RUN apk add --no-cache dumb-init
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
WORKDIR /app
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./
RUN npm ci --only=production --legacy-peer-deps
COPY --from=builder --chown=nodejs:nodejs /app/server.js ./
COPY --from=builder --chown=nodejs:nodejs /app/build ./build/
USER nodejs
EXPOSE 3002
ENV NODE_ENV=production PORT=3002
ENTRYPOINT ["dumb-init", "--"]
CMD ["node", "server.js"]
```

### Deployment Commands
- Create a single deployment script deploy.sh
- The script should work for both local and spcs deployment
- The script should setup app role and warehouse
- The script should setup the sample dataset if required
- The script should setup image_repo
- The script should build docker image and push it to Snowflake
- Then it should start the service and wait for endpoints to be available
- **CRITICAL**: Always use `-c default` flag in all snowsql commands to specify connection